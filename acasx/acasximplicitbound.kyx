SharedDefinitions.

  R abs(R).
  R max(R, R).
  R min(R, R).
  
  /* velocity bound 1 = lower, -1 = upper */
  R wUp() = (-1).
  R wLo() = (1).

  R maxI(R w, R dhf, R dhd) = ( max(0, w * (dhf - dhd)) ).
  R maxIM(R w, R dhfM, R dhd) = ( max((0,w*(dhfM-dhd))) ).

  /* Remark: under the condition w*dhd<=w*dhfM, we always have dhfM = (dhd+w*maxIM) */
  B CM(R w, R dhfM, R dhd, R r, R h) <-> (
    \forall t \forall ro \forall ho (
        (0 <= t & t < maxI(w,dhfM,dhd)/aM() & ro = rv * t & ho = (w * aM())/2 * t^2 + dhd * t)
      | (t >= maxI(w,dhfM,dhd)/aM() & ro = rv * t & ho = (dhd+w*maxI(w,dhfM,dhd)) * t - w * maxI(w,dhfM,dhd)^2/(2*aM()))
      -> (abs(r - ro) > rp() | w * h > w * ho + hp())
    )
  ).

  /* todo adapt names to paper r=r, h=h, dhd=v, w=w, dhf=vlo */
  B C(R w, R dhf, R dhd, R r, R h) <-> (
    \forall t \forall ro \forall ho (
        (0 <= t & t < maxI(w,dhf,dhd)/a() & ro = rv * t & ho = (w * a())/2 * t^2 + dhd * t)
      | (t >= maxI(w,dhf,dhd)/a() & ro = rv * t & ho = dhf * t - w * maxI(w,dhf,dhd)^2/(2*a()))
      -> (abs(r - ro) > rp() | w * h < w * ho - hp())
    )
  ).

  /* todo refactoring idea: might be possible to define C and CM from same base def. */
  /* B C(R w, R dhf, R dhd, R r, R h) <-> ( CBase(w, dhf, dhd, r, h, a(), -hp()) ). */
  /* B CM(R w, R dhfM, R dhd, R r, R h) <-> ( CBase(w, dhfM, dhd, r, h, aM(), hp()) ). */
  /* B CBase(R w, R dhf, R dhd, R r, R h, R a2, R hp2) <-> (
    \forall t \forall ro \forall ho (
        (0 <= t & t < maxI(w,dhf,dhd)/a2 & ro = rv * t & ho = (w * a2)/2 * t^2 + dhd * t)
      | (t >= maxI(w,dhf,dhd)/a2 & ro = rv * t & ho = dhf * t - w * maxI(w,dhf,dhd)^2/(2*a2))
      -> (abs(r - ro) > rp() | w * h < w * ho + hp2)
    )
  ).*/

  B initBounds() <-> ( hp()>0 & rp()>=0 & rv>=0 ).

  B init(R a) <-> ( initBounds() & a>0 ).

  B initAll() <-> ( initBounds() & a()>0 & aM()>0 ).

  B loopInv(R w, R dhf, R dhfM, R dhd, R r, R h) <-> (
    ((w=wUp() | w=wLo()) & (C(w,dhf,dhd,r,h) | CM(w,dhfM,dhd,r,h))) & initAll()
  ).

  B advisory(R w, R dhf, R dhd, R ao) <-> ( w*dhd>=w*dhf|w*ao>=a() ).

  B advisoryUp(R w, R dhfM, R dhd, R ao) <-> ( (w*dhd<=w*dhfM & w*ao<=aM|w*ao<=0) ).

  B evolutionDomain(R w, R dhf, R dhfM, R dhd, R ao) <-> ( advisory(w,dhf,dhd,ao) & advisoryUp(w,dhfM,dhd,ao) ).

  HP motion ::= { {r' = -rv, h' = -dhd, dhd' = ao &
                             evolutionDomain(w,dhf,dhfM,dhd,ao) }
  }.

End.


Lemma "Theorem 4: Correctness of lower bound".

ProgramVariables.
  /** Variables **/
   /* horizontal */
  R r.    /* relative distance in ft; xi - xo */
          /* x = r */
  R rv.   /* relative speed -(vi - vo) */
   /* vertical */
  R h.    /* relative altitude in ft */
          /* if negative: the intruder is lower than the ownship */
          /* h := hi - ho */
          /* z = h */
  R dhd.  /* vertical velocity of ownship */
  R dhf.  /* target minimum velocity */
  R dhfM. /* target maximum velocity (soft bound) */
  R w.    /* velocity bound 1 = lower, -1 = upper */
  R ao.   /* vertical acceleration of ownship */
  /** Constants **/
  R hp.   /* puck height */
  R rp.   /* puck radius */
  R a.    /* minimal vertical acceleration. Typically g/4 */
  R aM.   /* maximal vertical acceleration. Typically g/2 or g/3 */
  R tl.   /* time during which advisory needs to be followed */
  R to.   /* time passed since last advisory */

  R t.
  R ro.
  R ho.

  R t_. /*added variable*/

End.

/* LOWER BOUND */
Problem.
   t_>=0 &
   (t_+to<=tl|tl < 0) &
   \forall t \forall ro \forall ho ((t<=tl-to|tl < 0)&(0<=t&t < maxI(0,dhf,dhd)/a&ro=rv*t&ho=w*a/2*t^2+dhd*t|t>=maxI(0,dhf,dhd)/a&ro=rv*t&ho=dhf*t-w*maxI(0,dhf,dhd)^2/(2*a))->abs(r-ro)>rp|w*h < w*ho-hp) &
   hp>0 &
   (w*dhd>=w*dhf|w*ao>=a) &
   (w*(ao*t_+dhd)>=w*dhf|w*ao>=a) &
   (w=-1|w=1) &
   rp>=0 &
   rv>=0 &
   a>0
 ->
   \forall t \forall ro \forall ho ((t<=tl-(t_+to)|tl < 0)&(0<=t&t < max((0,w*(dhf-(ao*t_+dhd))))/a&ro=rv*t&ho=w*a/2*t^2+(ao*t_+dhd)*t|t>=max((0,w*(dhf-(ao*t_+dhd))))/a&ro=rv*t&ho=dhf*t-w*max((0,w*(dhf-(ao*t_+dhd))))^2/(2*a))->abs((-rv)*t_+r-ro)>rp|w*(-(ao/2*t_^2+dhd*t_)+h) < w*ho-hp)
End.

Tactic "prove Theorem 4: correctness of lower bound".
print({`lemma`}); implyR('R); (andL('L)*);
  print({`Before skolem`}); (allR('R)*); print({`After skolem`});
  implyR('R); orR('R);
  allL( {`t_+t`}, 'L);
  allL( {`rv*(t_+t)`}, 'L);
  abbrv({`maxI(w,dhf,dhd)`}, {`maxI`});
  print({`Before cases`});
  cut({`0<=t_+t & t_+t<maxI/a | t_+t>=maxI/a`}); <(
    print({`Use cut`});
    orL('L=={`0<=t_+t & t_+t<maxI/a | t_+t>=maxI/a`}); <(
      print({`Goal 110`}); hideL('L=={`w*dhd>=w*dhf|w*ao>=a`});
      allL({`w*a/2*(t_+t)^2 + dhd*(t_+t)`}, 'L);
        print({`instantiate ho 1 Lo`});
          implyL('L=={`(t_+t<=tl-to|tl < 0)&(0<=t_+t&t_+t < max((0,0*(dhf-dhd)))/a&rv*(t_+t)=rv*(t_+t)&w*a/2*(t_+t)^2+dhd*(t_+t)=w*a/2*(t_+t)^2+dhd*(t_+t)|t_+t>=max((0,0*(dhf-dhd)))/a&rv*(t_+t)=rv*(t_+t)&w*a/2*(t_+t)^2+dhd*(t_+t)=dhf*(t_+t)-w*max((0,0*(dhf-dhd)))^2/(2*a))->abs(r-rv*(t_+t))>rp|w*h < w*(w*a/2*(t_+t)^2+dhd*(t_+t))-hp`});
          <(
          print({`left of -> 1 Lo`}); andL('L);
            hideR('R=={`abs((-rv)*t_+r-ro)>rp`}); hideR('R=={`w*(-(ao/2*t_^2+dhd*t_)+h)<w*ho-hp`});
            doall(QE); print({`tl 1 QE`});
            done
          ,
          print({`right of -> 1 Lo`});
            andL('L=={`(t<=tl-(t_+to)|tl < 0)&(0<=t&t < max((0,w*(dhf-(ao*t_+dhd))))/a&ro=rv*t&ho=w*a/2*t^2+(ao*t_+dhd)*t|t>=max((0,w*(dhf-(ao*t_+dhd))))/a&ro=rv*t&ho=dhf*t-w*max((0,w*(dhf-(ao*t_+dhd))))^2/(2*a))`});
            hideL('L=={`t<=tl-(t_+to)|tl < 0`});
            doall(QE); print({`tl 2 QE`});
            done
          ),
       print({`final time in straight Lo`});
         allL({`dhf*(t_+t) - w*maxI^2/(2*a)`}, 'L);
         print({`instantiate ho 2 Lo`});
           implyL('L=={`(t_+t<=tl-to|tl < 0)&dhf*(t_+t)-w*maxI^2/(2*a)=dhf*(t_+t)-w*maxI^2/(2*a)->abs(r-rv*(t_+t))>rp|w*h < w*(dhf*(t_+t)-w*maxI^2/(2*a))-hp`});
           <(
            print({`left of -> 2 Lo`}); andL('L);
              cohideR('R);
              hideL('L=={`maxI=max((0,w*(dhf-dhd)))`});
              QE; print({`final time in straight Lo QE`});
              done
            ,
            print({`right of -> 2 Lo`});
              andL('L=={`(t<=tl-(t_+to)|tl < 0)&(0<=t&t < max((0,w*(dhf-(ao*t_+dhd))))/a&ro=rv*t&ho=w*a/2*t^2+(ao*t_+dhd)*t|t>=max((0,w*(dhf-(ao*t_+dhd))))/a&ro=rv*t&ho=dhf*t-w*max((0,w*(dhf-(ao*t_+dhd))))^2/(2*a))`});
              hideL('L=={`t_+to<=tl|tl < 0`});
              QE; print({`right of -> 2 Lo QE`});
              done
          )
    )
    ,
    print({`SHOW CUT`})
)

End.

End.


Lemma "Theorem 4: Correctness of upper bound".

ProgramVariables.
  /** Variables **/
   /* horizontal */
  R r.    /* relative distance in ft; xi - xo */
          /* x = r */
  R rv.   /* relative speed -(vi - vo) */
   /* vertical */
  R h.    /* relative altitude in ft */
          /* if negative: the intruder is lower than the ownship */
          /* h := hi - ho */
          /* z = h */
  R dhd.  /* vertical velocity of ownship */
  R dhf.  /* target minimum velocity */
  R dhfM. /* target maximum velocity (soft bound) */
  R w.    /* velocity bound 1 = lower, -1 = upper */
  R ao.   /* vertical acceleration of ownship */
  /** Constants **/
  R hp.   /* puck height */
  R rp.   /* puck radius */
  R a.    /* minimal vertical acceleration. Typically g/4 */
  R aM.   /* maximal vertical acceleration. Typically g/2 or g/3 */
  R tl.   /* time during which advisory needs to be followed */
  R to.   /* time passed since last advisory */

  R t.
  R ro.
  R ho.

  R t_. /*added variable*/

End.

/* UPPER BOUND */
Problem.
  t_>=0 &
  (t_+to<=tl|tl < 0) &
  \forall t \forall ro \forall ho ((t<=tl-to|tl < 0)&(0<=t&t < maxIM(w,dhfM,dhd)/aM&ro=rv*t&ho=w*aM/2*t^2+dhd*t|t>=maxIM(w,dhfM,dhd)/aM&ro=rv*t&ho=(dhd+w*maxIM(w,dhfM,dhd))*t-w*maxIM(w,dhfM,dhd)^2/(2*aM))->abs(r-ro)>rp|w*h>w*ho+hp) &
  hp>0 &
  (w*dhd<=w*dhfM&w*ao<=aM|w*ao<=0) &
  (w*(ao*t_+dhd)<=w*dhfM&w*ao<=aM|w*ao<=0) &
  (w=-1|w=1) &
  rp>=0 &
  rv>=0 &
  aM>0
->
  \forall t \forall ro \forall ho ((t<=tl-(t_+to)|tl < 0)&(0<=t&t < max((0,w*(dhfM-(ao*t_+dhd))))/aM&ro=rv*t&ho=w*aM/2*t^2+(ao*t_+dhd)*t|t>=max((0,w*(dhfM-(ao*t_+dhd))))/aM&ro=rv*t&ho=(ao*t_+dhd+w*max((0,w*(dhfM-(ao*t_+dhd)))))*t-w*max((0,w*(dhfM-(ao*t_+dhd))))^2/(2*aM))->abs((-rv)*t_+r-ro)>rp|w*(-(ao/2*t_^2+dhd*t_)+h)>w*ho+hp)
End.

Tactic "prove Theorem 4: correctness of upper bound".

print({`lemma Up`}); implyR('R); andL('L)*;
  print({`Before skolem Up`}); allR('R)*; print({`After skolem Up`});
  implyR('R); orR('R);
  allL( {`t_+t`}, 'L);
  allL( {`rv*(t_+t)`}, 'L);
  print({`Before cases`});
  abbrv({`maxIM(w,dhfM,dhd)`}, {`maxIM`});
  cut({`0<=t_+t&t_+t<maxIM/aM | t_+t>=maxIM/aM`});
  <(
    print({`Use cut`});
    orL('L=={`0<=t_+t&t_+t<maxIM/aM | t_+t>=maxIM/aM`});
    <(
      print({`final time in parabola`});
        allL({`w*aM/2*(t_+t)^2+dhd*(t_+t)`}, 'L);
        print({`instantiate ho 1 Up`});
        implyL('L=={`(t_+t<=tl-to|tl < 0)&(0<=t_+t&t_+t < maxIM/aM&rv*(t_+t)=rv*(t_+t)&w*aM/2*(t_+t)^2+dhd*(t_+t)=w*aM/2*(t_+t)^2+dhd*(t_+t)|t_+t>=maxIM/aM&rv*(t_+t)=rv*(t_+t)&w*aM/2*(t_+t)^2+dhd*(t_+t)=(dhd+w*maxIM)*(t_+t)-w*maxIM^2/(2*aM))->abs(r-rv*(t_+t))>rp|w*h>w*(w*aM/2*(t_+t)^2+dhd*(t_+t))+hp`});
        <(
          print({`left of -> 1 Up`});
          /* cohideR('R); cohideOnlyR('Rlast)
          hideL('L=={`maxIM=max((0,w*(dhfM-dhd)))`}); */
          QE; done
          ,
          print({`right of -> 1 Up`});
          andL('L=={`(t<=tl-(t_+to)|tl < 0)&(0<=t&t < max((0,w*(dhfM-(ao*t_+dhd))))/aM&ro=rv*t&ho=w*aM/2*t^2+(ao*t_+dhd)*t|t>=max((0,w*(dhfM-(ao*t_+dhd))))/aM&ro=rv*t&ho=(ao*t_+dhd+w*max((0,w*(dhfM-(ao*t_+dhd)))))*t-w*max((0,w*(dhfM-(ao*t_+dhd))))^2/(2*aM))`});
          hideL('L=={`t<=tl-(t_+to)|tl < 0`});
          QE; print({`right of -> 1 Up QE`}); done
        ),
      print({`final time in straight Up`});
        allL({`(dhd+w*maxIM)*(t_+t)-w*maxIM^2/(2*aM)`}, 'L);
        print({`instantiate ho 2 Lo`});
        implyL('L=={`(t_+t<=tl-to|tl < 0)&(0<=t_+t&t_+t < maxIM/aM&rv*(t_+t)=rv*(t_+t)&(dhd+w*maxIM)*(t_+t)-w*maxIM^2/(2*aM)=w*aM/2*(t_+t)^2+dhd*(t_+t)|t_+t>=maxIM/aM&rv*(t_+t)=rv*(t_+t)&(dhd+w*maxIM)*(t_+t)-w*maxIM^2/(2*aM)=(dhd+w*maxIM)*(t_+t)-w*maxIM^2/(2*aM))->abs(r-rv*(t_+t))>rp|w*h>w*((dhd+w*maxIM)*(t_+t)-w*maxIM^2/(2*aM))+hp`});
        <(
        print({`left of -> 1 Up`});
          /*cohideR('R); cohideOnlyR('Rlast) try cohide2
          hideL('L=={`maxIM=max((0,w*(dhfM-dhd)))`});*/
          QE; print({`left of -> 2 Up QE`}); done
        ,
        print({`right of -> 2 Up`});
          andL('L=={`(t<=tl-(t_+to)|tl < 0)&(0<=t&t < max((0,w*(dhfM-(ao*t_+dhd))))/aM&ro=rv*t&ho=w*aM/2*t^2+(ao*t_+dhd)*t|t>=max((0,w*(dhfM-(ao*t_+dhd))))/aM&ro=rv*t&ho=(ao*t_+dhd+w*max((0,w*(dhfM-(ao*t_+dhd)))))*t-w*max((0,w*(dhfM-(ao*t_+dhd))))^2/(2*aM))`});
          hideL('L=={`t<=tl-(t_+to)|tl < 0`});
          QE; print({`right of -> 2 Up QE`}); done
        )
   ),
   print({`SHOW CUT`})
 )

End.

Theorem "Theorem 4: Main".

ProgramVariables.
  /** Variables **/
   /* horizontal */
  R r.    /* relative distance in ft; xi - xo */
          /* x = r */
  R rv.   /* relative speed -(vi - vo) */
   /* vertical */
  R h.    /* relative altitude in ft */
          /* if negative: the intruder is lower than the ownship */
          /* h := hi - ho */
          /* z = h */
  R dhd.  /* vertical velocity of ownship */
  R dhf.  /* target minimum velocity */
  R dhfM. /* target maximum velocity (soft bound) */
  R w.    /* velocity bound 1 = lower, -1 = upper */
  R ao.   /* vertical acceleration of ownship */
  /** Constants **/
  R hp.   /* puck height */
  R rp.   /* puck radius */
  R a.    /* minimal vertical acceleration. Typically g/4 */
  R aM.   /* maximal vertical acceleration. Typically g/2 or g/3 */
  R tl.   /* time during which advisory needs to be followed */
  R to.   /* time passed since last advisory */

  R t.
  R ro.
  R ho.
End.

Problem.
  (hp > 0 & rp >= 0 & rv >= 0 & a > 0 & aM > 0) /* maybe aM>=a? */ &
  ( ((w=-1 | w=1) & (to<=tl | tl<0)) &
    (
      (
        \forall t \forall ro \forall ho
        ((t<=tl-to | tl<0) &
         ((0 <= t & t < max(0, w * (dhf - dhd)) / a &
           ro = rv * t & ho = (w * a) / 2 * t^2 + dhd * t) |
          (t >= max(0, w * (dhf - dhd)) / a &
           ro = rv * t & ho = dhf * t - w * max(0, w * (dhf - dhd))^2 / (2*a)))
         -> (abs(r - ro) > rp | w * h < w * ho - hp))
      ) |
      (
        \forall t \forall ro \forall ho
        ((t<=tl-to | tl<0) &
         ((0 <= t & t < max(0, w * (dhfM - dhd)) / aM &
           ro = rv * t & ho = (w * aM) / 2 * t^2 + dhd * t) |
          (t >= max(0, w * (dhfM - dhd)) / aM &
           ro = rv * t & ho = (dhd + w * max(0, w * (dhfM-dhd))) * t - w * max(0, w * (dhfM - dhd))^2 / (2*aM)))
         -> (abs(r - ro) > rp | w * h > w * ho + hp))
      )
    )
  )
  -> [
  {   {
      { ?true; ++
        { to:=0; dhf :=*; dhfM :=*; {w:=-1; ++ w:=1;}
         ?(
      (
        \forall t \forall ro \forall ho
        ((t<=tl-to | tl<0) &
         ((0 <= t & t < max(0, w * (dhf - dhd)) / a &
           ro = rv * t & ho = (w * a) / 2 * t^2 + dhd * t) |
          (t >= max(0, w * (dhf - dhd)) / a &
           ro = rv * t & ho = dhf * t - w * max(0, w * (dhf - dhd))^2 / (2*a)))
         -> (abs(r - ro) > rp | w * h < w * ho - hp))
      ) |
      (
        \forall t \forall ro \forall ho
        ((t<=tl-to | tl<0) &
         ((0 <= t & t < max(0, w * (dhfM - dhd)) / aM &
           ro = rv * t & ho = (w * aM) / 2 * t^2 + dhd * t) |
          (t >= max(0, w * (dhfM - dhd)) / aM &
           ro = rv * t & ho = (dhd + w * max(0, w * (dhfM-dhd))) * t - w * max(0, w * (dhfM - dhd))^2 / (2*aM)))
         -> (abs(r - ro) > rp | w * h > w * ho + hp))
      )   );
        } }
        ao :=*;
      }
      {r' = -rv, h' = -dhd, dhd' = ao, to'=1 &
       (to<=tl | tl<0) &
       (( w * dhd >= w * dhf  | w * ao >= a ) &
        ((w * dhd <= w * dhfM & w * ao <= aM) | w * ao <= 0)) }
   }*
  ] ( (abs(r) > rp | abs(h) > hp) &
      ( ((w=-1 | w=1) & (to<=tl | tl<0)) &
        (
      (
        \forall t \forall ro \forall ho
        ((t<=tl-to | tl<0) &
         ((0 <= t & t < max(0, w * (dhf - dhd)) / a &
           ro = rv * t & ho = (w * a) / 2 * t^2 + dhd * t) |
          (t >= max(0, w * (dhf - dhd)) / a &
           ro = rv * t & ho = dhf * t - w * max(0, w * (dhf - dhd))^2 / (2*a)))
         -> (abs(r - ro) > rp | w * h < w * ho - hp))
      ) |
      (
        \forall t \forall ro \forall ho
        ((t<=tl-to | tl<0) &
         ((0 <= t & t < max(0, w * (dhfM - dhd)) / aM &
           ro = rv * t & ho = (w * aM) / 2 * t^2 + dhd * t) |
          (t >= max(0, w * (dhfM - dhd)) / aM &
           ro = rv * t & ho = (dhd + w * max(0, w * (dhfM-dhd))) * t - w * max(0, w * (dhfM - dhd))^2 / (2*aM)))
         -> (abs(r - ro) > rp | w * h > w * ho + hp))
      )
        )
      )
    )
End.

Tactic "prove Theorem 4: Main".

implyR('R); andL('L)*;
  loop({`loopInv(w, dhf, dhfM, dhd, r, h)`},'R)
  <(
    /*initCase*/
      print({`Base Case`});
      prop;
      done;
      print({`Base Case Done`})
    ,
    /*use*/
      print({`Use case`});
      andL('L);
      hideL('L=={`hp>0&rp>=0&rv>=0&a>0&aM>0`});
      andR('R); <(
        useLemma({`Thm 3: Use Case Low`}, {`prop`}); done,
        andL('L); closeId
      );
      done
    ,
    /*step*/
      print({`Step`});
      hideL('L=={`hp>0&rp>=0&rv>=0&a>0&aM>0`});
      composeb('R);
      MR({`loopInv(w, dhf, dhfM, dhd, r, h)`},1);
      <(
        print({`Generalization Holds`});
        print({`1.21`}); chase('R); print({`After chase`});
        ((fullSimplify; andL('L)*)*); print({`Simplified`});
        /* closeT */
        done,
        /*use*/
        print({`Generalization Strong Enough`});
        cut({``!evolutionDomain(w,dhf,dhfM,dhd,ao) | evolutionDomain(w,dhf,dhfM,dhd,ao)`});
        <(
          orL('L=={`!evolutionDomain(w,dhf,dhfM,dhd,ao) | evolutionDomain(w,dhf,dhfM,dhd,ao)`});
          <(
            print({`Not evolutionDomain`});
              hideL('L=={`loopInv(w, dhf, dhfM, dhd, r, h)`});
              DI('R); notL('L); closeId; done
            ,
            print({`evolutionDomain`});
              print({`Before diff. solution`});
              abbrv({`max(0,w*(dhf-dhd))`}, {`maxI`});
              abbrv({`max(0,w*(dhfM-dhd))`}, {`maxIM`});
              solveEnd('R);
              print({`Diff. Solution`}); allR('R); implyR('R)*2; (andL('L)*); print({`Now what?`}); fullSimplify; print({`Simplified 2`});
              orR('R);
              hideL('L=={`to<=tl|tl < 0`});
              orL('L=={`\forall t \forall ro \forall ho ((t<=tl-to|tl < 0)&(0<=t&t < maxI/a&ro=rv*t&ho=w*a/2*t^2+dhd*t|t>=maxI/a&ro=rv*t&ho=dhf*t-w*maxI^2/(2*a))->abs(r-ro)>rp|w*h < w*ho-hp)|\forall t \forall ro \forall ho ((t<=tl-to|tl < 0)&(0<=t&t < maxIM/aM&ro=rv*t&ho=w*aM/2*t^2+dhd*t|t>=maxIM/aM&ro=rv*t&ho=(dhd+w*maxIM)*t-w*maxIM^2/(2*aM))->abs(r-ro)>rp|w*h>w*ho+hp)`});
              <(
                print({`Before hide lower`});
                  hideL('L=={`maxIM=max((0,w*(dhfM-dhd)))`}); hideL('L=={`aM>0`});
                  hideL('L=={`w*dhd<=w*dhfM&w*ao<=aM|w*ao<=0`});
                  hideL('L=={`w*(ao*t_+dhd)<=w*dhfM&w*ao<=aM|w*ao<=0`});
                  hideR('R=={`\forall t \forall ro \forall ho ((t<=tl-(t_+to)|tl < 0)&(0<=t&t < max(0,w*(dhfM-(ao*t_+dhd)))/aM&ro=rv*t&ho=w*aM/2*t^2+(ao*t_+dhd)*t|t>=max(0,w*(dhfM-(ao*t_+dhd)))/aM&ro=rv*t&ho=(ao*t_+dhd+w*max(0,w*(dhfM-(ao*t_+dhd))))*t-w*max(0,w*(dhfM-(ao*t_+dhd)))^2/(2*aM))->abs((-rv)*t_+r-ro)>rp|w*(-(ao/2*t_^2+dhd*t_)+h)>w*ho+hp)`});
                  print({`lower lemma`})
                  /*
                    dT("lower lemma") & PropositionalTactics.toSingleFormula &
                    by(lemmaDB.get("bounded_safe_implicit").getOrElse(throw new BelleAbort("Incomplete", "Lemma bounded_safe_implicit must be proved first"))),
                  */
                ,
                print({`Before hide upper`});
                  hideL('L=={`maxI=max((0,w*(dhf-dhd)))`}); hideL('L=={`a>0`});
                  hideL('L=={`w*dhd>=w*dhf|w*ao>=a`});
                  hideL('L=={`w*(ao*t_+dhd)>=w*dhf|w*ao>=a`});
                  hideR('R=={`\forall t \forall ro \forall ho ((t<=tl-(t_+to)|tl < 0)&(0<=t&t < max(0,w*(dhf-(ao*t_+dhd)))/a&ro=rv*t&ho=w*a/2*t^2+(ao*t_+dhd)*t|t>=max(0,w*(dhf-(ao*t_+dhd)))/a&ro=rv*t&ho=dhf*t-w*max(0,w*(dhf-(ao*t_+dhd)))^2/(2*a))->abs((-rv)*t_+r-ro)>rp|w*(-(ao/2*t_^2+dhd*t_)+h) < w*ho-hp)`});
                  print({`upper lemma`})
                  /*
                    dT("upper lemma") & PropositionalTactics.toSingleFormula &
                    by(lemmaDB.get("bounded_safe_upimplicit").getOrElse(throw new BelleAbort("Incomplete", "Lemma bounded_safe_upimplicit must be proved first")))
                  */
              )
            )
          ,
          print({`Print CUT`})
        )
       )
   )

End.


Theorem "Lemma 4a: time-limited implicit-explicit lower equivalence".

ProgramVariables.
/** Variables **/
 /* horizontal */
  R r.    /* relative distance in ft; xi - xo */
        /* x = r */
  R rv.   /* relative speed -(vi - vo) */
  /* vertical */
  R h.    /* relative altitude in ft */
          /* if negative: the intruder is lower than the ownship */
          /* h := hi - ho */
          /* z = h */
  R dhd.  /* vertical velocity of ownship */
  R dhfM.  /* taMget maximum velocity */
  R w.    /* velocity bound 1 = lower, -1 = upper */
  R ao.   /* vertical acceleration of ownship */
  /** Constants **/
  R hp.   /* puck height */
  R rp.   /* puck radius */
  R aM.   /* maximum vertical acceleration. Typically g/3 or g/2 */
  R to.
  R tl.

  R t.
  R ro.
  R ho.
End.

Problem.
  (hp > 0 & rp >= 0 & rv >= 0 & aM > 0) & (w=-1 | w=1) & (to<=tl | tl<0) -> (
  (
   (w * (dhd + w * max(0, w * (dhfM - dhd))) > 0 ->
    (
     ((-rp <= r & r <= rp) -> w * h > hp)
     &
     ((rp < r & r <= rp + rv * max(0, w*(dhfM - dhd))/aM & (r <= rp + rv * (tl-to) | tl < 0))  ->
      (w * rv^2 * h > aM/2 * (r - rp)^2 + w * rv * dhd * (r - rp) + rv^2 * hp))
     &
     ((-rp <= r & r < -rp + rv * max(0, w*(dhfM - dhd))/aM  & (r <= -rp + rv * (tl-to) | tl < 0)) ->
      (w * rv^2 * h > aM/2 * (r + rp)^2 + w * rv * dhd * (r + rp) + rv^2 * hp))
     &
     ((-rp + rv * max(0, w*(dhfM - dhd))/aM <= r & (r < -rp + rv*(tl-to) | tl<0)) ->
      ((rv = 0 & r > rp) |
       w * rv * h > w * (dhd + w * max(0, w * (dhfM - dhd))) * (r + rp) - rv * max(0, w*(dhfM - dhd))^2 / (2*aM) + rv*hp))
     &
     ((-rp + rv*(tl-to) <= r & r<= rp + rv*(tl-to))->
      (tl < 0 |
       (
        (rv = 0 & r > rp) |
        ((max(0, w*(dhfM - dhd))/aM <= (tl-to) -> w * h > w * (dhd + w * max(0, w * (dhfM - dhd))) * (tl-to) - max(0, w*(dhfM - dhd))^2 / (2*aM)  + hp)
        &
        (max(0, w*(dhfM - dhd))/aM > (tl-to) -> w * h > aM/2 * (tl-to)^2 + w * dhd * (tl-to) + hp))
       ))
     )
     ))
    &
    ((w * (dhd + w * max(0, w * (dhfM - dhd))) <= 0) ->
      ((-rp <= r & r <= rp) -> w * h > hp)
      &
      ((rp < r & r <= rp + rv * max(0, w*(dhfM - dhd))/aM & (r <= rp + rv * (tl-to) | tl < 0)) ->
        w * rv^2 * h > aM/2 * (r - rp)^2 + w * rv * dhd * (r - rp) + rv^2 * hp)
      &
      ((rp + rv * max(0, w*(dhfM - dhd))/aM < r & (r<=rp + rv*(tl-to) | tl < 0)) ->
       (rv = 0 |
        w * rv * h > w * (dhd + w * max(0, w * (dhfM - dhd))) * (r - rp) - rv * max(0, w*(dhfM - dhd))^2 / (2*aM) + rv*hp))
      )
  ) <->
  (
    \forall t \forall ro \forall ho
    ((t<=tl-to | tl<0) &
     ((0 <= t & t < max(0, w * (dhfM - dhd)) / aM &
      ro = rv * t & ho = (w * aM) / 2 * t^2 + dhd * t) |
     (t >= max(0, w * (dhfM - dhd)) / aM &
      ro = rv * t &
      ho = (dhd + w * max(0, w * (dhfM-dhd))) * t
            - w * max(0, w * (dhfM - dhd))^2 / (2*aM)))
     -> (abs(r - ro) > rp | w * h > w * ho + hp))
  )
  )
End.

Tactic "prove Lemma 4a: time-limited implicit-explicit lower equivalence".

implyR('R); equivR('R);
<(
  print({`Case ->`});
    allR('R)*; print({`Afte Case -> skolemize`}); implyR('R);
    andL('L=={`(t<=tl-to|tl < 0)&(0<=t&t < max((0,w*(dhf-dhd)))/a&ro=rv*t&ho=w*a/2*t^2+dhd*t|t>=max((0,w*(dhf-dhd)))/a&ro=rv*t&ho=dhf*t-w*max((0,w*(dhf-dhd)))^2/(2*a))`});
    orL('L=={`tl-to < 0&tl>=0|(w*dhf>=0->((-rp<=r&r < -rp-rv*min((0,w*dhd))/a)&(r<=-rp+rv*(tl-to)|tl < 0)->w*rv^2*h < a/2*(r+rp)^2+w*rv*dhd*(r+rp)-rv^2*hp)&((-rp-rv*min((0,w*dhd))/a<=r&r<=rp-rv*min((0,w*dhd))/a)&(-min((0,w*dhd))/a<=tl-to|tl < 0)->w*h < (-min((0,w*dhd))^2)/(2*a)-hp)&((rp-rv*min((0,w*dhd))/a < r&r<=rp+rv*max((0,w*(dhf-dhd)))/a)&(r<=rp+rv*(tl-to)|tl < 0)->w*rv^2*h < a/2*(r-rp)^2+w*rv*dhd*(r-rp)-rv^2*hp)&(rp+rv*max((0,w*(dhf-dhd)))/a < r&(r<=rp+rv*(tl-to)|tl < 0)->rv=0|w*rv*h < w*dhf*(r-rp)-rv*max((0,w*(dhf-dhd)))^2/(2*a)-rv*hp))&(w*dhf < 0->((-rp<=r&r < -rp+rv*max((0,w*(dhf-dhd)))/a)&(r < -rp+rv*(tl-to)|tl < 0)->w*rv^2*h < a/2*(r+rp)^2+w*rv*dhd*(r+rp)-rv^2*hp)&(-rp+rv*max((0,w*(dhf-dhd)))/a<=r&(r < -rp+rv*(tl-to)|tl < 0)->rv=0&r>rp|w*rv*h < w*dhf*(r+rp)-rv*max((0,w*(dhf-dhd)))^2/(2*a)-rv*hp)&((-rp+rv*(tl-to)<=r&r<=rp+rv*(tl-to))&tl>=0->tl-to<0|0<=tl-to&tl-to<=max((0,w*(dhf-dhd)))/a&w*h < a/2*(tl-to)^2+w*dhd*(tl-to)-hp|tl-to>max((0,w*(dhf-dhd)))/a&w*h < w*dhf*(tl-to)-max((0,w*(dhf-dhd)))^2/(2*a)-hp))`});
    <(
      print({`-> : tl-to < 0&tl>0`});
      /*ACASX_Bounded_Case_Imply0*/
      cut({`t <= tl-to | tl < 0`});
      <(
        orL({`t <= tl-to | tl < 0`});
        <(
          QE; print({`-> : tl-to < 0&tl>=0 QE`}); done
          ,
          hideL('L=={`0<=t&t < max((0,w*(dhf-dhd)))/a&ro=rv*t&ho=w*a/2*t^2+dhd*t|t>=max((0,w*(dhf-dhd)))/a&ro=rv*t&ho=dhf*t-w*max((0,w*(dhf-dhd)))^2/(2*a)`}); done
        )
        ,
        print({`Show cut`});
      )
      ,
      print({`-> unlimited-time lower equiv`});
      cut({`w*dhf>=0 | w*dhf<0`});
      <(
        orL({`w*dhf>=0 | w*dhf<0`});
        <(
          print({`Case w*dhf>=0`});
            andL('L)*;
            abbrv({`max((0,w*(dhf-dhd)))`}, {`maxA`});
            abbrv({`min((0,w*dhd))`}, {`minA`});
            /*
            max('L, "max(0,w*(dhf-dhd))".asTerm) &
            min('L, "min(0,w*dhd)".asTerm) &
            abs('R, "abs(r-ro)".asTerm) & Idioms.cases(QE)
            */
            cut({`r < -rp | -rp<=r&r < -rp-rv*minA/a | -rp-rv*minA/a<=r&r<=rp-rv*minA/a | rp-rv*minA/a < r&r<=rp+rv*maxA/a | rp+rv*maxA/a < r`});
            <(
              orL({`r < -rp | -rp<=r&r < -rp-rv*minA/a | -rp-rv*minA/a<=r&r<=rp-rv*minA/a | rp-rv*minA/a < r&r<=rp+rv*maxA/a | rp+rv*maxA/a < r`});
              <(
                print({`-> 0:r<- rp`});
                  hideL('L=={`p_()&q_() -> r_()`}); /*(hideL('Llike, "p_()&q_() -> r_()".asFormula)*3)/
                  QE;
                  done
                ,
                print({`-> 1:(-rp<=r & r < -rp-rv*minA/a)`});
                  hideL('L=={`p_()&q_() -> r_()`}); /*(hideL('Llike, "p_()&q_() -> r_()".asFormula)*3)*/
                  /*ACASX_Bounded_Case_Imply1*/
                  implyL('L=={`(r<=-rp+rv*(tl-to)|tl < 0->w*rv^2*h < a/2*(r+rp)^2+w*rv*dhd*(r+rp)-rv^2*hp)`});
                  <(
                    QE;
                    done
                    ,
                    QE; print({`-> 1:(-rp<=r & r < -rp-rv*minA/a) QE`});
                    done
                  )
                ,
                print({`-> 2: -rp-rv*minA/a<=r&r<=rp-rv*minA/a`});
                  hideL({'L=={`p_()&q_() -> r_()`}}); /*(hideL('Llike, "p_()&q_() -> r_()".asFormula)*3)*/
                  /*ACASX_Bounded_Case_Imply2*/
                  implyL('L=={`-minA/a<=tl-to|tl < 0->w*h < (-minA^2)/(2*a)-hp`});
                  <(
                    QE;
                    done
                    ,
                    QE; print{`-> 2: -rp-rv*minA/a<=r&r<=rp-rv*minA/a QE`};
                    done
                  )
                ,
                print({`-> 3: rv*minA/a<=r&r<=rp-rv*minA/`});
                  hideL('L=={`p_()&q_() -> r_()`}); /*(hideL('Llike, "p_()&q_() -> r_()".asFormula)*3)*/
                  /*ACASX_Bounded_Case_Imply3*/
                  QE;
                  print({`-> 3 QE`});
                  done
                ,
                print({`-> 4: rp+rv*maxA/a < r`});
                  hideL('L=={`p_()&q_() -> r_()`});
                  /*ACASX_Bounded_Case_Imply4*/
                  QE;
                  print({`-> 4 QE`});
                  done
              )
              ,
              print({`Show cut`})
            )
          ,
          print({`w*dhf<0`});
          andL('L)*;
          abbrv({`max((0,w*(dhf-dhd)))`}, {`maxA`});
          /*
          max('L, "max(0,w*(dhf-dhd))".asTerm) &
          abs('R, "abs(r-ro)".asTerm) &
          */
          cut({`(r< -rp)&(r< -rp+rv*(tl-to)&tl>=0|tl<0) | (-rp<=r&r < -rp+rv*maxA/a)&(r< -rp+rv*(tl-to)|tl<0) | (-rp+rv*maxA/a<=r)&(r< -rp+rv*(tl-to)|tl<0) | (-rp+rv*(tl-to)<=r&r<=rp+rv*(tl-to))&(tl>=0) | (r>rp+rv*(tl-to))&(tl>=0)`});
          <(
            orL('L=={`(r< -rp)&(r< -rp+rv*(tl-to)&tl>=0|tl<0) | (-rp<=r&r < -rp+rv*maxA/a)&(r< -rp+rv*(tl-to)|tl<0) | (-rp+rv*maxA/a<=r)&(r< -rp+rv*(tl-to)|tl<0) | (-rp+rv*(tl-to)<=r&r<=rp+rv*(tl-to))&(tl>=0) | (r>rp+rv*(tl-to))&(tl>=0)`});
            <(
              print({`-> 4-5`});
                hideL('L=={`p_()&q_() -> r_()`}); /*(hideL('Llike, "p_()&q_() -> r_()".asFormula)*3)*/
                /*ACASX_Bounded_Case_Imply4to5*/
                QE;
                print({`-> 4-5 QE`});
                done
              ,
              print({`-> 5`});
                hideL('L=={`p_()&q_() -> r_()`}); /*(hideL('Llike, "p_()&q_() -> r_()".asFormula)*2)*/
                /*ACASX_Bounded_Case_Imply5*/
                QE;
                print({`-> 5 QE`});
                done
              ,
              print({`-> 6`});
                hideL('L=={`p_()&q_() -> r_()`}); /*(hideL('Llike, "p_()&q_() -> r_()".asFormula)*2)*/
                /*ACASX_Bounded_Case_Imply6*/
                QE;
                print({`-> 6 QE`});
                done
              ,
              print({`-> 7`});
                hideL('L=={`p_()&q_() -> r_()`}); /*(hideL('Llike, "p_()&q_() -> r_()".asFormula)*2)*/
                /*ACASX_Bounded_Case_Imply7*/
                QE;
                print({`-> 7 contradiction QE`});
                done
              ,
              print({`-> 8`});
                hideL('L=={`p_()&q_() -> r_()`}); /*(hideL('Llike, "p_()&q_() -> r_()".asFormula)*3)*/
                /*ACASX_Bounded_Case_Imply8*/
                cut({`rp=0 | rp>0`});
                <(
                  orL('L=={`rp=0 | rp>0`});
                  <(
                    orR('R); hideR('R=={`w*h < w*ho-hp`}); print({`-> 8 Case rp=0`}); QE
                    ,
                    orL('L=={`0<=t&t < maxA/a&ro=rv*t&ho=w*a/2*t^2+dhd*t|t>=maxA/a&ro=rv*t&ho=dhf*t-w*maxA^2/(2*a)`}); print({`-> 8 Case rp>0`}); QE
                  )
                  ,
                  print({`Show cut`})
                )
            )
          )
        )
        ,
        print({`Show cut`})
      )
    )





)

val tactic = implyR('R) & equivR('R) & Idioms.<(
  dT("Case ->") &
    (allR('R)*) & dT("After Case -> skolemize") & implyR('R)  &
    andL('L, "(t<=tl-to|tl < 0)&(0<=t&t < max((0,w*(dhf-dhd)))/a&ro=rv*t&ho=w*a/2*t^2+dhd*t|t>=max((0,w*(dhf-dhd)))/a&ro=rv*t&ho=dhf*t-w*max((0,w*(dhf-dhd)))^2/(2*a))".asFormula) &
    orL('L, "tl-to < 0&tl>=0|(w*dhf>=0->((-rp<=r&r < -rp-rv*min((0,w*dhd))/a)&(r<=-rp+rv*(tl-to)|tl < 0)->w*rv^2*h < a/2*(r+rp)^2+w*rv*dhd*(r+rp)-rv^2*hp)&((-rp-rv*min((0,w*dhd))/a<=r&r<=rp-rv*min((0,w*dhd))/a)&(-min((0,w*dhd))/a<=tl-to|tl < 0)->w*h < (-min((0,w*dhd))^2)/(2*a)-hp)&((rp-rv*min((0,w*dhd))/a < r&r<=rp+rv*max((0,w*(dhf-dhd)))/a)&(r<=rp+rv*(tl-to)|tl < 0)->w*rv^2*h < a/2*(r-rp)^2+w*rv*dhd*(r-rp)-rv^2*hp)&(rp+rv*max((0,w*(dhf-dhd)))/a < r&(r<=rp+rv*(tl-to)|tl < 0)->rv=0|w*rv*h < w*dhf*(r-rp)-rv*max((0,w*(dhf-dhd)))^2/(2*a)-rv*hp))&(w*dhf < 0->((-rp<=r&r < -rp+rv*max((0,w*(dhf-dhd)))/a)&(r < -rp+rv*(tl-to)|tl < 0)->w*rv^2*h < a/2*(r+rp)^2+w*rv*dhd*(r+rp)-rv^2*hp)&(-rp+rv*max((0,w*(dhf-dhd)))/a<=r&(r < -rp+rv*(tl-to)|tl < 0)->rv=0&r>rp|w*rv*h < w*dhf*(r+rp)-rv*max((0,w*(dhf-dhd)))^2/(2*a)-rv*hp)&((-rp+rv*(tl-to)<=r&r<=rp+rv*(tl-to))&tl>=0->tl-to<0|0<=tl-to&tl-to<=max((0,w*(dhf-dhd)))/a&w*h < a/2*(tl-to)^2+w*dhd*(tl-to)-hp|tl-to>max((0,w*(dhf-dhd)))/a&w*h < w*dhf*(tl-to)-max((0,w*(dhf-dhd)))^2/(2*a)-hp))".asFormula) & Idioms.<(
      dT("-> : tl-to < 0&tl>=0") &
      Idioms.rememberAs("ACASX_Bounded_Case_Imply0",
        Idioms.cases(QE)(
          (Case("t <= tl-to".asFormula), atomicQE(onAll(orL('L))*, dT("-> : tl-to < 0&tl>=0 QE")) & done)
          ,
          (Case("tl < 0".asFormula),
            hideL('L, "0<=t&t < max((0,w*(dhf-dhd)))/a&ro=rv*t&ho=w*a/2*t^2+dhd*t|t>=max((0,w*(dhf-dhd)))/a&ro=rv*t&ho=dhf*t-w*max((0,w*(dhf-dhd)))^2/(2*a)".asFormula) & QE)
          )
      )
      ,
      dT("-> unlimited-time lower equiv") & Idioms.cases(QE)(
        (Case("w*dhf>=0".asFormula),
          dT("Case w*dhf>=0") &
          (andL('L)*) &
          EqualityTactics.abbrv("max((0,w*(dhf-dhd)))".asTerm, Some(Variable("maxA"))) &
          EqualityTactics.abbrv("min((0,w*dhd))".asTerm, Some(Variable("minA"))) &
          max('L, "max(0,w*(dhf-dhd))".asTerm) &
          min('L, "min(0,w*dhd)".asTerm) &
          abs('R, "abs(r-ro)".asTerm) & Idioms.cases(QE)(
            (Case("r < -rp".asFormula), dT("-> 0:r<-rp") & (hideL('Llike, "p_()&q_() -> r_()".asFormula)*3) & QE & done),
            (Case("-rp<=r&r < -rp-rv*minA/a".asFormula), dT("-> 1:(-rp<=r & r < -rp-rv*minA/a)") &
              (hideL('Llike, "p_()&q_() -> r_()".asFormula)*3) &
              Idioms.rememberAs("ACASX_Bounded_Case_Imply1",
                implyL('L, "(r<=-rp+rv*(tl-to)|tl < 0->w*rv^2*h < a/2*(r+rp)^2+w*rv*dhd*(r+rp)-rv^2*hp)".asFormula) & Idioms.<(
                  QE & done
                  ,
                  atomicQE(ArithmeticLibrary.exhaustiveBeta, dT("-> 1:(-rp<=r & r < -rp-rv*minA/a) QE")) & done
                ) & done)
            ),
            (Case("-rp-rv*minA/a<=r&r<=rp-rv*minA/a".asFormula), dT("-> 2: -rp-rv*minA/a<=r&r<=rp-rv*minA/a") &
              (hideL('Llike, "p_()&q_() -> r_()".asFormula)*3) &
              Idioms.rememberAs("ACASX_Bounded_Case_Imply2",
                implyL('L, "-minA/a<=tl-to|tl < 0->w*h < (-minA^2)/(2*a)-hp".asFormula) & Idioms.<(
                  QE & done,
                  atomicQE(ArithmeticLibrary.exhaustiveBeta, dT("-> 2: -rp-rv*minA/a<=r&r<=rp-rv*minA/a QE")) & done
                ) & done)
            ),
            (Case("rp-rv*minA/a < r&r<=rp+rv*maxA/a".asFormula), dT("-> 3: rv*minA/a<=r&r<=rp-rv*minA/") &
              (hideL('Llike, "p_()&q_() -> r_()".asFormula)*3) &
              Idioms.rememberAs("ACASX_Bounded_Case_Imply3",
                atomicQE(ArithmeticLibrary.exhaustiveBeta, dT("-> 3 QE")) & done
              )
            ),
            (Case("rp+rv*maxA/a < r".asFormula), dT("-> 4: rp+rv*maxA/a < r") &
              (hideL('Llike, "p_()&q_() -> r_()".asFormula)*2) &
              Idioms.rememberAs("ACASX_Bounded_Case_Imply4",
                atomicQE(ArithmeticLibrary.exhaustiveBeta, dT("-> 4 QE")) & done)
            )
          )
        )
        ,
        (Case("w*dhf<0".asFormula), dT("w*dhf<0") &
          (andL('L)*) &
          EqualityTactics.abbrv("max((0,w*(dhf-dhd)))".asTerm, Some(Variable("maxA"))) &
          max('L, "max(0,w*(dhf-dhd))".asTerm) &
          abs('R, "abs(r-ro)".asTerm) &
          Idioms.cases(QE)(
            (Case("(r< -rp)&(r< -rp+rv*(tl-to)&tl>=0|tl<0)".asFormula), dT("-> 4-5") &
              (hideL('Llike, "p_()&q_() -> r_()".asFormula)*3) &
              Idioms.rememberAs("ACASX_Bounded_Case_Imply4to5",
                atomicQE(ArithmeticLibrary.exhaustiveBeta, dT("-> 4-5 QE")) & done
              )
            ),
            (Case("(-rp<=r&r < -rp+rv*maxA/a)&(r< -rp+rv*(tl-to)|tl<0)".asFormula), dT("-> 5") &
              (hideL('Llike, "p_()&q_() -> r_()".asFormula)*2) &
              Idioms.rememberAs("ACASX_Bounded_Case_Imply5",
                atomicQE(ArithmeticLibrary.exhaustivePropositional, dT("-> 5 QE")) & done)

            ),
            (Case("(-rp+rv*maxA/a<=r)&(r< -rp+rv*(tl-to)|tl<0)".asFormula), dT("-> 6") &
              (hideL('Llike, "p_()&q_() -> r_()".asFormula)*2) &
              Idioms.rememberAs("ACASX_Bounded_Case_Imply6",
                atomicQE(ArithmeticLibrary.exhaustivePropositional, dT("-> 6 QE")) & done)
            ),
            (Case("(-rp+rv*(tl-to)<=r&r<=rp+rv*(tl-to))&(tl>=0)".asFormula), dT("-> 7") &
              (hideL('Llike, "p_()&q_() -> r_()".asFormula)*2) &
              Idioms.rememberAs("ACASX_Bounded_Case_Imply7",
                atomicQE(ArithmeticLibrary.exhaustiveBeta, dT("-> 7 contradiction QE")) & done)
            ),
            (Case("(r>rp+rv*(tl-to))&(tl>=0)".asFormula),
              dT("-> 8") &
                (hideL('Llike, "p_()&q_() -> r_()".asFormula)*3) &
                Idioms.rememberAs("ACASX_Bounded_Case_Imply8",
                Idioms.cases(QE)(
                  (Case("rp=0".asFormula), orR('R) & hideR('R, "w*h < w*ho-hp".asFormula) & dT("-> 8 Case rp=0") & QE),
                  (Case("rp>0".asFormula), orL('L, "0<=t&t < maxA/a&ro=rv*t&ho=w*a/2*t^2+dhd*t|t>=maxA/a&ro=rv*t&ho=dhf*t-w*maxA^2/(2*a)".asFormula) & dT("-> 8 Case rp>0") & onAll(QE))
                )
              )
            )
          )
        )
      )
    )
  ,
  dT("<-") & Idioms.cases(QE)(
    (Case("tl<0".asFormula),
      dT("<- unlimited time lower equiv") &
      Idioms.rememberAs("ACASX_Bounded_TimeLowerA", lweqvA(
        ///////////// B
        QE,
        ///////////// S
        Idioms.cases(QE)(
          (Case("(h+w*maxA^2/(2*a))/dhf>=maxA/a".asFormula),
            allTRoHoL("S >= maxA/a", "(h+w*maxA^2/(2*a))/dhf", "0", "h") &
            implyL('L) & Idioms.<(cohideOnlyR('Rlast) & QE, QE)
          ),
          (Case("(h+w*maxA^2/(2*a))/dhf<maxA/a".asFormula),
            allTRoHoL("S < maxA/a", "maxA/a", "0", "dhf*maxA/a-w*maxA^2/(2*a)") &
            implyL('L) & Idioms.<(cohideOnlyR('Rlast) & QE, QE)
          )
        ),
        ///////////// V
        allTRoHoL("<- 6", "(r+rp)/rv", "rv*((r+rp)/rv)", "dhf*((r+rp)/rv)-w*maxA^2/(2*a)") & QE
    ))),
    (Case("tl>=0".asFormula), Idioms.cases(QE)(
      (Case("tl-to<0".asFormula), dT("tl>=0 Case tl-to<0") & QE),
      (Case("tl-to>=0".asFormula),
        dT("tl>=0 Case tl-to>=0") &
          Idioms.rememberAs("ACASX_Bounded_TimeLowerB", lweqvA(
            ///////////// B
            SimplifierV2.fullSimpTac & atomicQE(onAll(implyL('L))*, dT("B QE")),
            ///////////// S
            andR('R) & Idioms.<(
              allTRoHoL("S inst", "-maxA/a", "rv*(-maxA/a)", "dhf*(-max/a)-w*max^2/(2*a)") & QE,
              Idioms.cases(QE)(
                (Case("tl-to > maxA/a".asFormula),
                  allTRoHoL("<- 7: 1", "tl-to", "rv*(tl-to)", "dhf*(tl-to)-w*maxA^2/(2*a)") &
                  SimplifierV2.fullSimpTac & atomicQE(onAll(implyL('L))*, dT("W QE")))
                ,
                (Case("tl-to <= maxA/a".asFormula),
                  allTRoHoL("<- 7: 2", "tl-to", "rv*(tl-to)", "w*a/2*(tl-to)^2+dhd*(tl-to)") &
                  SimplifierV2.fullSimpTac & atomicQE(onAll(implyL('L))*, dT("X QE")))
              )
            ),
            ///////////// V
            (andL('L)*) & SimplifierV2.fullSimpTac & dT("<- V") &
              andR('R) & Idioms.<(
                implyR('R) &
                allTRoHoL("<- 6", "(r+rp)/rv", "rv*((r+rp)/rv)", "dhf*((r+rp)/rv)-w*maxA^2/(2*a)") &
                atomicQE(ArithmeticLibrary.varEliminationLeft("w".asVariable), dT("<- V QE 1")) & done
                ,
                implyR('R) & Idioms.cases(QE)(
                  (Case("tl-to > maxA/a".asFormula),
                    allTRoHoL("<- 7 A", "tl-to", "rv*(tl-to)", "dhf*(tl-to)-w*maxA^2/(2*a)") &
                    atomicQE(ArithmeticLibrary.varEliminationLeft("w".asVariable), dT("<- V QE 2")) & done
                  ),
                  (Case("tl-to <= maxA/a".asFormula),
                    allTRoHoL("<- 7 B", "tl-to", "rv*(tl-to)", "w*a/2*(tl-to)^2+dhd*(tl-to)") &
                    atomicQE(ArithmeticLibrary.varEliminationLeft("w".asVariable), dT("<- V QE 3")) & done)
                )
              )
          ))
      )
    ))
  )
)

End.
